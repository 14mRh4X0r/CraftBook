Perlstone Spec v1.0

Perlstone, named for Perl of which which is often compared to line noise, is a
small scripting language for use in Minecraft servers which intergrates with
Minecraft's Redstone system for making what amounts to electrical circuitry.

Perlstone has a stack of booleans, a presistant variable table containing 32
fields, indexed with the values 0-9 or a-u, a temp variable table containing 32
fields, indexed indentically to the presistant variable table, a function local
variable table identical to the temp and presistant variable tables, and 3
input registers. The script is formatted into up to ten function strings,
seperated by the character ':', and indexed to numbers 0 though 99, all of
which may return a boolean value.

Each function contains an arbitary number of opcodes, which may take arguments
(which are pushed onto the function's stack when it is called) and optionally
returns a single boolean value. When a function is called, a new function local
variable table is created, starting with all 'false' values, which will be used
for the duration of the function.

---Opcodes---
[opcode][arguments] (stack arguments -> opcode return value) - description

Constant functions:
+ (->t) - pushes 'true' onto the stack
- (->t) - pushes 'false' onto the stack

Variable functions:
A (->a) - pushes contents the A input register onto the stack
B (->b) - pushes contents the B input register onto the stack
C (->c) - pushes contents the C input register onto the stack

Srn (v->) - pops the top value of the stack, and stores it to slot n in the
            table r (p for presistant, t for temp, l for local) 
Lrn (->v) - pushes the value n in the table r (defined as in the >rn opcode)
            onto the stack

Stack fuctions:
d (a->aa) - duplicates the top value of the stack
p (a->) - pops the top value of the stack, and discards it
vn (v(...)->v) - copies the value n values down in the stack onto the top

Logical functions:
! (a->r) - pops the top value of the stack, and pushes it's inverse
^ (ab->r) - pops the top two values of the stack, and pushes the xor of them
& (ab->r) - pops the top two values of the stack, and pushes the and of them
| (ab->r) - pops the top two values of the stack, and pushes the or of them
= (ab->r) - pops the top two values of the stack, and pushes their equality
.abcd (ef->r) - custom logic gate, pops the top two values of the stack (e and
                f) and if ef is 00, pushes a onto the stack, if ef is 01, 
                pushes b onto the stack, if ef is 10 pushes c onto the stack
                and if ef is 11 pushes d onto the stack.

Flow control functions:
cffn (123...->r?) - pops n values off the stack, calls, the function f
                    (referenced by number), and pushes the previously popped 
                    values onto the called function's stack, and returns the 
                    return value, if one exists, of the called function onto 
                    the calling function's stack.
tffn (123...->r?) - calls the function defined by f with n arguments are in c,
                    pops the top value of the stack, and returns it.
[c] (v->) - if v is 'false,' skip to the end of the code block defined by c. 
            otherwise, execute the code block defined by c. on completion, 
            repeat this command.

s - returns from the current function
r (v->) - pops the top value of the stack, and pushes that value onto the stack
          of the calling function and returns from the current function

--Future--

Version 2: Functional style programming, with changes including combinators,
           and other unlambda styled antics. (Effectively making the types
           boolean and function)